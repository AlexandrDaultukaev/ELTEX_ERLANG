1. Создайте модуль protocol.erl и создайте заголовочный файл protocol.hrl.
Протестируйте функцию в Eshell с помощью данных:

![Снимок экрана от 2023-03-22 23-29-36](https://user-images.githubusercontent.com/60806892/226978144-adb40f6e-bd54-4705-9b92-750eaae931ba.png)

### ---===/ <i>Комментарий</i> /===---
Я сделал throw для неправильного аргумента и exit для неправильной версии, но потом прочитал(https://ru.hexlet.io/courses/erlang_101/lessons/practical_erlang_let_it_crash/theory_unit)
что следовало бы использовать error, т.к. throw, кажется, подразумевает обрабатываемое исключение, exit - системное сообщение, а error - как раз необрабатываемое исключение, которое прерывает текущий поток.
### -----======-----


Замените в Data2 данные на любые другие - при этом у вас изменится поле TotalLength
(отмечено цветным)
### ---===/ <i>Комментарий</i> /===---
Вот тут не совсем понял: эта переменная ни на что не влияет, но если бы и влияла, я должен с помощью erlang:bit_size(msg) измерить сообщение и это класть в TotalLength?
### -----======-----


2. Eshell:
2.1 Вызовите предыдущую функцию в новом процессе с валидными данными Data1
или Data2 (spawn/3)
2.2 Проверьте ваш pid (self/0).
Вызовите предыдущую функцию protocol:ipv4(Data) в новом процессе (spawn/3) с
DataWrongFormat или DataWrongVer.
Проверьте ваш pid (self/0).
Изменился ли он после того как предыдущая строка завершилась ошибкой?
Почему?
Необязательное задание- если есть время
Вызовите protocol:ipv4(Data) в spawn/1 (которая в качестве аргумента ожидает
анонимную функцию).

![Снимок экрана от 2023-03-22 23-32-26](https://user-images.githubusercontent.com/60806892/226981361-c7896ce0-ec55-448b-bbff-d92f25c7eaa0.png)

![Снимок экрана от 2023-03-22 23-34-14](https://user-images.githubusercontent.com/60806892/226981428-6ffd1a10-75aa-4f05-8bfb-6e5ac52a645e.png)

### ---===/ <i>Комментарий</i> /===---
Я так понимаю, наш pid не изменился, потому что spawn порождает дочерний процесс, он завершается аварийно и умирает сам по себе
### -----======-----

2.3 В модуле protocol реализуйте функцию protocol:ipv4_listener/0, которая ожидает
получения сообщения {ipv4, From, BinData} и если получает, то вызывает функцию
protocol:ipv4(BinData) и отправляет результат From.
Добавьте охранное выражение в receive, что BinData это binary.
Обработайте случай, что функция получила сообщение другого формата и выведите
ошибку или вызовите exception.
Запустите функцию protocol:ipv4_listener/0 в новом процессе с помощью spawn/3 или
spawn/1. Сохраните pid нового процесса в переменную ListenerPid.
Отправьте из Eshell сообщение ListenerPid с валидными данными Data1 или Data2.
ListenerPid ! {ipv4, self(), Data}
Или
Msg = {ipv4, self(), Data}.
erlang:send(ListenerPid, Msg).
С помощью команды flush/0 проверьте, что вы получили ответ.
Попробуйте отправить данные которые не подходят по формату
![Снимок экрана от 2023-03-22 23-40-35](https://user-images.githubusercontent.com/60806892/226982202-d4a743ea-1b48-48d7-a0a0-a7cc909b1722.png)

![Снимок экрана от 2023-03-22 23-42-44](https://user-images.githubusercontent.com/60806892/226982214-ed6a5c84-c1e5-4bf2-9f76-398016220f56.png)
![Снимок экрана от 2023-03-22 23-44-39](https://user-images.githubusercontent.com/60806892/226982228-b0c418b7-6f9c-4b85-af98-67329bba9f87.png)
